# 컴퓨터 내부의 언어체계
컴퓨터는 비트(bit)를 통해서 정보를 전달하고 읽는다. 비트는 2진법을 사용한다. 0과 1 두가지 값만 가질 수 있다. 비트들을 조합해서 더욱 복잡한 정보를 나타내고 의미를 부여할 수 있다. 

## 정수를 비트로 표현하는 법
### 양의 정수 표현
수학 시간에 배운 2진법과 같다. 
```
00000001 -> 1
00000010 -> 2
```

컴퓨터에서는 비트를 통해서 연산을 진행한다. 덧셈 연산을 통해서 오버플로우가 발생할 수 있다. 

```
  11111111
+ 00000001
= 00000000

```

즉 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 넘어서면 **오버플로우가** 발생한다. 

### 음의 정수 표현 
양의 정수뿐만 아니라 음의 정수도 표현할 수 있어야한다. 비트를 통해서 어떻게 음수를 표현할 수 있을까? 
부호와 크기 표현법, 1의 보수(1을 0으로 0을 1로 바꾸는 법) 등등이 있지만 메모모리 낭비의 문제가 있기 때문에 2의 보수를 사용한다. 

2의 보수법은 예시로 이해하는 것이 쉽다.
```
   0001
+  1111
=  0000
```

더해서 0을 만들 수 있는 이진법 수를 만들면된다.

## 실수를 표현하는 법 
대학 화학 책이나 생물 책을 보면 소수를 `1.2324242`이런 식으로 표현하지 않고 `1.23 * 10^2` 이런 식으로 표현한다. 이런 표현법을 부동수소점 표현법이라고 한다. 
`1.23 * 10^-2` 언뜻 보면 소수점이 고정되어있는 것 처럼 보이지만 지수에 따라 달라질 수 있기 때문에 **부동소수점**이라는 이름이 붙여졌다. 컴퓨터는 이진법을 사용하기 때문에 밑이 10이 아니라 2인 형태이다. 

**왜 고정소수점이 아닌 부동소수점을 사용했을까?** 고정소수점을 사용하면 정수 부분, 분수 부분을 저장하는데 범위가 넓은 실수 값을 표현하기에 사용되는 비트 개수가 너무 많기 때문에 범용적으로 쓰이지 않는다. 

## 텍스트를 표현하는 법
지금까지는 비트를 통해서 실수,정수 등을 표현할 수 있는 방법을 살펴봤다. 수를 사용해서 텍스트를 표현할 수 있는 방법을 살펴보자.

### 아스키코드
아스키는 모든 기호에 대해 7비트 수 값을 할당했다. 중요한 점은 아스키코드는 non printable characters와 printable characters로 나뉠 수 있다. 그 중 control character라고 불리는 제어 문자가 있다. 
상당수가 통신 제어를 위한 문자다. HTTP에서 볼 수 있는 ACK등과 같은 문자들이다. (printable한 글자는 A,B,C같은 것들) 아스키코드는 컴퓨터 초기에 확립된 표준이기 때문에 printalbe character는 알파벳밖에 없다. 

### UNICODE
시간이 지나서 많은 나라들에 컴퓨터가 보급되었다. 이제 다른 나라 언어들도 지원해야했다. 그래서 생겨난 표준이 **유티코드**이다. 처음에는 16비트에 저장했지만 시간이 지남에 따라 이모티콘을 지원하는 등 여러가지 문자들을 추가로 지원해 21비트까지 확장되었다. 

### UTF-8
UNICODE는 21비트를 사용한다. 아스키 문자(아스키 코드에 있는 문자들)는 8비트(엄밀하게 말하면 7비트)를 사용한다. 그렇다면 8비트만 가지고도 아스키 문자를 표현할 수 있는데 굳이 21비트나 사용해야할까?

이런 문제점을 해결하기 위해서 UTF-8이 등장했다. UTF-8은 문자마다 다른 비트 덩어리를 할당하는 식으로 해결했다. 예를 들어 유니코드 A는 8비트, 유니코드 U+1F340 16비트를 사용하는 식이다. (엄밀히 말하자면 UTF-8 덩어리 3개 자세한 설명은 생략)

## 바이너리 데이터를 다루는 법
바이너리 데이터는 숫자다. 하지만 바이너리 데이터를 직접 보내는 것은 문제가 있었다. 앞서 아스키코드 중 control-character 같은 코드가 예약어로 잡혀있어서 데이터를 잘못 읽을 수 있고 또 시스템마다 control-character가 다르기도 하다. 
그리고 몇몇 시스템은 7비트만 정보를 교환할 수 있었다.

이를 해결하고자 바이너리데이터를 printable-data만을 이용해서 표현하는 **베이스64 인코딩**이 등장했다. 안전하게 바이너리 데이터를 주고 받을 수 있게 되었다. 




